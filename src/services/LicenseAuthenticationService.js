/**
 * License & Authentication Service
 * Provides secure access control with company-based licensing
 * 
 * Features:
 * - License key validation from oqualtix@outlook.com
 * - Admin access control
 * - Company-based user management
 * - One user per bank account/company card restriction
 * - Secure token-based authentication
 * - License expiration and renewal
 */

import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import moment from 'moment';

class LicenseAuthenticationService {
  constructor() {
    this.licensePath = './licenses/';
    this.userDataPath = './user_data/';
    this.adminEmails = ['oqualtix@outlook.com', 'admin@oqualtix.com'];
    this.encryptionKey = 'OQUALTIX_SECURE_KEY_2025'; // In production, use environment variable
    
    // Ensure directories exist
    this.ensureDirectories();
    
    // Load existing licenses and users
    this.loadLicenseData();
    
    console.log('ðŸ” License & Authentication Service initialized');
  }

  // Ensure required directories exist
  ensureDirectories() {
    [this.licensePath, this.userDataPath].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  // Load license and user data
  loadLicenseData() {
    try {
      // Load active licenses
      this.activeLicenses = this.loadFromFile('active_licenses.json', {});
      
      // Load company data
      this.companyData = this.loadFromFile('company_data.json', {});
      
      // Load user assignments
      this.userAssignments = this.loadFromFile('user_assignments.json', {});
      
      console.log(`ðŸ“Š Loaded ${Object.keys(this.activeLicenses).length} active licenses`);
      console.log(`ðŸ¢ Loaded ${Object.keys(this.companyData).length} company profiles`);
      
    } catch (error) {
      console.error('âŒ Error loading license data:', error);
      this.initializeEmptyData();
    }
  }

  // Initialize empty data structures
  initializeEmptyData() {
    this.activeLicenses = {};
    this.companyData = {};
    this.userAssignments = {};
  }

  // Load data from file with fallback
  loadFromFile(filename, fallback = {}) {
    const filePath = path.join(this.licensePath, filename);
    
    if (fs.existsSync(filePath)) {
      try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
      } catch (error) {
        console.warn(`âš ï¸  Could not parse ${filename}:`, error.message);
        return fallback;
      }
    }
    
    return fallback;
  }

  // Save data to file
  saveToFile(filename, data) {
    const filePath = path.join(this.licensePath, filename);
    
    try {
      fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
      return true;
    } catch (error) {
      console.error(`âŒ Error saving ${filename}:`, error);
      return false;
    }
  }

  // Generate new license key (Admin only)
  generateLicenseKey(companyInfo, issuedBy = 'oqualtix@outlook.com') {
    if (!this.isAdminEmail(issuedBy)) {
      throw new Error('License keys can only be generated by authorized administrators');
    }

    const licenseId = this.generateUniqueId();
    const licenseKey = this.generateSecureLicenseKey();
    
    const licenseData = {
      licenseId: licenseId,
      licenseKey: licenseKey,
      companyName: companyInfo.companyName,
      contactEmail: companyInfo.contactEmail,
      bankAccounts: companyInfo.bankAccounts || [],
      companyCards: companyInfo.companyCards || [],
      maxUsers: this.calculateMaxUsers(companyInfo.bankAccounts, companyInfo.companyCards),
      
      // License metadata
      issuedBy: issuedBy,
      issuedDate: new Date().toISOString(),
      expirationDate: moment().add(1, 'year').toISOString(),
      status: 'ACTIVE',
      
      // Usage tracking
      activatedDate: null,
      lastAccessDate: null,
      accessCount: 0,
      
      // Security
      activationHash: null,
      ipRestrictions: companyInfo.ipRestrictions || [],
      
      // Features
      features: {
        realTimeFraudDetection: true,
        microSkimmingDetection: true,
        bankStatementAnalysis: true,
        notificationSystem: true,
        auditReporting: true,
        apiAccess: companyInfo.apiAccess || false
      }
    };

    // Store license
    this.activeLicenses[licenseKey] = licenseData;
    this.saveToFile('active_licenses.json', this.activeLicenses);

    console.log(`ðŸ”‘ New license generated for ${companyInfo.companyName}`);
    console.log(`ðŸ“§ License key issued by: ${issuedBy}`);
    console.log(`ðŸ‘¥ Maximum users allowed: ${licenseData.maxUsers}`);

    return {
      licenseKey: licenseKey,
      licenseId: licenseId,
      companyName: companyInfo.companyName,
      maxUsers: licenseData.maxUsers,
      expirationDate: licenseData.expirationDate,
      features: licenseData.features
    };
  }

  // Calculate maximum users based on bank accounts and cards
  calculateMaxUsers(bankAccounts = [], companyCards = []) {
    // One user per bank account + one user per company card
    return bankAccounts.length + companyCards.length;
  }

  // Generate secure license key
  generateSecureLicenseKey() {
    const prefix = 'OQX';
    const timestamp = Date.now().toString(36).toUpperCase();
    const randomPart = crypto.randomBytes(8).toString('hex').toUpperCase();
    const checksum = this.calculateChecksum(timestamp + randomPart);
    
    return `${prefix}-${timestamp}-${randomPart}-${checksum}`;
  }

  // Calculate checksum for license key validation
  calculateChecksum(data) {
    return crypto.createHash('md5').update(data + this.encryptionKey).digest('hex').substr(0, 4).toUpperCase();
  }

  // Generate unique ID
  generateUniqueId() {
    return crypto.randomBytes(16).toString('hex');
  }

  // Validate license key format
  validateLicenseKeyFormat(licenseKey) {
    const pattern = /^OQX-[A-Z0-9]+-[A-F0-9]{16}-[A-F0-9]{4}$/;
    return pattern.test(licenseKey);
  }

  // Authenticate user with license key
  async authenticateUser(licenseKey, userInfo) {
    try {
      // Validate license key format
      if (!this.validateLicenseKeyFormat(licenseKey)) {
        return {
          success: false,
          error: 'Invalid license key format',
          code: 'INVALID_FORMAT'
        };
      }

      // Check if license exists
      const license = this.activeLicenses[licenseKey];
      if (!license) {
        return {
          success: false,
          error: 'License key not found',
          code: 'LICENSE_NOT_FOUND'
        };
      }

      // Validate license status
      const validationResult = this.validateLicense(license);
      if (!validationResult.valid) {
        return {
          success: false,
          error: validationResult.reason,
          code: validationResult.code
        };
      }

      // Check user assignment limits
      const assignmentResult = await this.validateUserAssignment(licenseKey, userInfo);
      if (!assignmentResult.allowed) {
        return {
          success: false,
          error: assignmentResult.reason,
          code: assignmentResult.code
        };
      }

      // Activate license if first use
      if (!license.activatedDate) {
        license.activatedDate = new Date().toISOString();
        license.activationHash = this.generateActivationHash(licenseKey, userInfo);
      }

      // Update license usage
      license.lastAccessDate = new Date().toISOString();
      license.accessCount = (license.accessCount || 0) + 1;

      // Create user session
      const sessionToken = await this.createUserSession(licenseKey, userInfo);

      // Save updated license data
      this.saveToFile('active_licenses.json', this.activeLicenses);

      console.log(`âœ… User authenticated: ${userInfo.email} for ${license.companyName}`);

      return {
        success: true,
        sessionToken: sessionToken,
        license: {
          companyName: license.companyName,
          expirationDate: license.expirationDate,
          features: license.features,
          maxUsers: license.maxUsers,
          assignedAccount: assignmentResult.assignedAccount
        },
        user: {
          email: userInfo.email,
          role: assignmentResult.role,
          permissions: assignmentResult.permissions
        }
      };

    } catch (error) {
      console.error('âŒ Authentication error:', error);
      return {
        success: false,
        error: 'Authentication failed',
        code: 'AUTH_ERROR'
      };
    }
  }

  // Validate license status and expiration
  validateLicense(license) {
    // Check license status
    if (license.status !== 'ACTIVE') {
      return {
        valid: false,
        reason: `License is ${license.status.toLowerCase()}`,
        code: 'LICENSE_INACTIVE'
      };
    }

    // Check expiration
    if (moment().isAfter(moment(license.expirationDate))) {
      return {
        valid: false,
        reason: 'License has expired',
        code: 'LICENSE_EXPIRED'
      };
    }

    return { valid: true };
  }

  // Validate user assignment to bank account/company card
  async validateUserAssignment(licenseKey, userInfo) {
    const license = this.activeLicenses[licenseKey];
    const companyAssignments = this.userAssignments[licenseKey] || {};

    // Check if user is already assigned
    const existingAssignment = Object.values(companyAssignments).find(
      assignment => assignment.userEmail === userInfo.email
    );

    if (existingAssignment) {
      return {
        allowed: true,
        reason: 'User already assigned',
        assignedAccount: existingAssignment.accountId,
        role: existingAssignment.role,
        permissions: existingAssignment.permissions
      };
    }

    // Check if requesting specific account assignment
    if (userInfo.requestedAccount) {
      return await this.assignUserToAccount(licenseKey, userInfo, userInfo.requestedAccount);
    }

    // Auto-assign to available account
    return await this.autoAssignUserToAccount(licenseKey, userInfo);
  }

  // Assign user to specific account
  async assignUserToAccount(licenseKey, userInfo, accountId) {
    const license = this.activeLicenses[licenseKey];
    const companyAssignments = this.userAssignments[licenseKey] || {};

    // Validate account exists
    const allAccounts = [...(license.bankAccounts || []), ...(license.companyCards || [])];
    const targetAccount = allAccounts.find(acc => acc.id === accountId);

    if (!targetAccount) {
      return {
        allowed: false,
        reason: 'Requested account not found',
        code: 'ACCOUNT_NOT_FOUND'
      };
    }

    // Check if account is already assigned
    const existingAssignment = companyAssignments[accountId];
    if (existingAssignment) {
      return {
        allowed: false,
        reason: `Account ${accountId} is already assigned to ${existingAssignment.userEmail}`,
        code: 'ACCOUNT_ALREADY_ASSIGNED'
      };
    }

    // Create assignment
    const assignment = {
      accountId: accountId,
      accountType: targetAccount.type, // 'bank_account' or 'company_card'
      userEmail: userInfo.email,
      userName: userInfo.name || userInfo.email,
      assignedDate: new Date().toISOString(),
      role: this.determineUserRole(userInfo),
      permissions: this.generateUserPermissions(userInfo, targetAccount),
      status: 'ACTIVE'
    };

    // Save assignment
    if (!this.userAssignments[licenseKey]) {
      this.userAssignments[licenseKey] = {};
    }
    this.userAssignments[licenseKey][accountId] = assignment;
    this.saveToFile('user_assignments.json', this.userAssignments);

    console.log(`ðŸ‘¤ User ${userInfo.email} assigned to account ${accountId}`);

    return {
      allowed: true,
      reason: 'User assigned to account',
      assignedAccount: accountId,
      role: assignment.role,
      permissions: assignment.permissions
    };
  }

  // Auto-assign user to available account
  async autoAssignUserToAccount(licenseKey, userInfo) {
    const license = this.activeLicenses[licenseKey];
    const companyAssignments = this.userAssignments[licenseKey] || {};

    // Get all available accounts
    const allAccounts = [...(license.bankAccounts || []), ...(license.companyCards || [])];
    const assignedAccountIds = Object.keys(companyAssignments);
    const availableAccounts = allAccounts.filter(acc => !assignedAccountIds.includes(acc.id));

    if (availableAccounts.length === 0) {
      return {
        allowed: false,
        reason: 'All accounts are already assigned. Maximum user limit reached.',
        code: 'MAX_USERS_REACHED'
      };
    }

    // Assign to first available account
    const targetAccount = availableAccounts[0];
    return await this.assignUserToAccount(licenseKey, userInfo, targetAccount.id);
  }

  // Determine user role based on email and company data
  determineUserRole(userInfo) {
    if (this.isAdminEmail(userInfo.email)) {
      return 'ADMIN';
    }

    // Check if user email matches company domain patterns
    if (userInfo.isManager || userInfo.role === 'manager') {
      return 'MANAGER';
    }

    return 'USER';
  }

  // Generate user permissions based on role and account
  generateUserPermissions(userInfo, account) {
    const basePermissions = [
      'view_transactions',
      'run_fraud_analysis',
      'view_reports'
    ];

    const role = this.determineUserRole(userInfo);

    switch (role) {
      case 'ADMIN':
        return [
          ...basePermissions,
          'manage_licenses',
          'manage_users',
          'system_configuration',
          'export_data',
          'delete_data'
        ];

      case 'MANAGER':
        return [
          ...basePermissions,
          'manage_company_users',
          'export_reports',
          'configure_alerts',
          'acknowledge_alerts'
        ];

      default:
        return basePermissions;
    }
  }

  // Create user session token
  async createUserSession(licenseKey, userInfo) {
    const sessionData = {
      licenseKey: licenseKey,
      userEmail: userInfo.email,
      timestamp: Date.now(),
      expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
    };

    const sessionToken = crypto
      .createHash('sha256')
      .update(JSON.stringify(sessionData) + this.encryptionKey)
      .digest('hex');

    // Store session (in production, use Redis or database)
    const sessionPath = path.join(this.userDataPath, 'active_sessions.json');
    const sessions = this.loadFromFile('active_sessions.json', {});
    sessions[sessionToken] = sessionData;
    
    try {
      fs.writeFileSync(sessionPath, JSON.stringify(sessions, null, 2));
    } catch (error) {
      console.error('âŒ Error saving session:', error);
    }

    return sessionToken;
  }

  // Validate session token
  async validateSession(sessionToken) {
    try {
      const sessions = this.loadFromFile('active_sessions.json', {});
      const session = sessions[sessionToken];

      if (!session) {
        return { valid: false, reason: 'Session not found' };
      }

      if (Date.now() > session.expiresAt) {
        // Clean up expired session
        delete sessions[sessionToken];
        this.saveToFile('active_sessions.json', sessions);
        return { valid: false, reason: 'Session expired' };
      }

      return {
        valid: true,
        licenseKey: session.licenseKey,
        userEmail: session.userEmail
      };
    } catch (error) {
      return { valid: false, reason: 'Session validation error' };
    }
  }

  // Check if email is admin
  isAdminEmail(email) {
    return this.adminEmails.includes(email.toLowerCase());
  }

  // Generate activation hash
  generateActivationHash(licenseKey, userInfo) {
    return crypto
      .createHash('sha256')
      .update(licenseKey + userInfo.email + this.encryptionKey)
      .digest('hex');
  }

  // Revoke license (Admin only)
  revokeLicense(licenseKey, revokedBy) {
    if (!this.isAdminEmail(revokedBy)) {
      throw new Error('Licenses can only be revoked by authorized administrators');
    }

    const license = this.activeLicenses[licenseKey];
    if (!license) {
      throw new Error('License not found');
    }

    license.status = 'REVOKED';
    license.revokedDate = new Date().toISOString();
    license.revokedBy = revokedBy;

    // Remove user assignments
    delete this.userAssignments[licenseKey];

    this.saveToFile('active_licenses.json', this.activeLicenses);
    this.saveToFile('user_assignments.json', this.userAssignments);

    console.log(`ðŸ”’ License revoked for ${license.companyName} by ${revokedBy}`);
    return true;
  }

  // Get license information
  getLicenseInfo(licenseKey) {
    const license = this.activeLicenses[licenseKey];
    if (!license) {
      return null;
    }

    const assignments = this.userAssignments[licenseKey] || {};
    
    return {
      companyName: license.companyName,
      status: license.status,
      expirationDate: license.expirationDate,
      maxUsers: license.maxUsers,
      assignedUsers: Object.keys(assignments).length,
      features: license.features,
      lastAccess: license.lastAccessDate,
      accessCount: license.accessCount
    };
  }

  // Get company statistics
  getCompanyStatistics() {
    const stats = {
      totalLicenses: Object.keys(this.activeLicenses).length,
      activeLicenses: 0,
      expiredLicenses: 0,
      revokedLicenses: 0,
      totalUsers: 0,
      totalCompanies: new Set()
    };

    Object.values(this.activeLicenses).forEach(license => {
      stats.totalCompanies.add(license.companyName);
      
      switch (license.status) {
        case 'ACTIVE':
          if (moment().isBefore(moment(license.expirationDate))) {
            stats.activeLicenses++;
          } else {
            stats.expiredLicenses++;
          }
          break;
        case 'REVOKED':
          stats.revokedLicenses++;
          break;
      }
    });

    Object.values(this.userAssignments).forEach(assignments => {
      stats.totalUsers += Object.keys(assignments).length;
    });

    stats.totalCompanies = stats.totalCompanies.size;

    return stats;
  }
}

export default LicenseAuthenticationService;