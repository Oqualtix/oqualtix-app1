import React, { createContext, useState, useContext, useEffect } from 'react';
// For demo purposes, we'll use a simple state management instead of AsyncStorage
// In a real app, you would use @react-native-async-storage/async-storage
import { ValidationUtils, EncryptionUtils, SessionUtils, AuditUtils } from '../utils/SecurityUtils';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Mock user database - in a real app, this would be a backend service
  const mockUsers = {
    'Oqualtix@outlook.com': {
      id: '1',
      email: 'Oqualtix@outlook.com',
      password: 'OqualtixAdmin2025!',
      name: 'Oqualtix Admin',
      phone: '+1-555-0123',
      role: 'admin',
    },
  };

  // User access codes generated by admin - in real app this would be in a secure database
  const [userAccessCodes, setUserAccessCodes] = useState({
    'DEMO2025': { 
      code: 'DEMO2025', 
      isUsed: false, 
      createdBy: 'Oqualtix@outlook.com',
      createdAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
    }
  });

  const [userDatabase, setUserDatabase] = useState(mockUsers);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      // For demo purposes, we'll skip persistent storage
      // In a real app, you would check AsyncStorage here
      setLoading(false);
    } catch (error) {
      console.error('Error checking auth status:', error);
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    // Validate inputs
    const emailValidation = ValidationUtils.validateEmail(email);
    if (!emailValidation.isValid) {
      return { success: false, error: emailValidation.error };
    }

    // Check if user is locked out
    if (SessionUtils.isLockedOut(email)) {
      AuditUtils.logSecurityEvent('LOGIN_ATTEMPT_WHILE_LOCKED', { email });
      return { success: false, error: 'Account temporarily locked due to too many failed attempts' };
    }

    // Check if this is admin login
    const foundUser = userDatabase[email];
    
    if (foundUser && foundUser.password === password) {
      // Admin login with password
      const passwordValidation = ValidationUtils.validatePassword(password);
      if (!passwordValidation.isValid) {
        return { success: false, error: passwordValidation.error };
      }

      // Clear failed attempts
      SessionUtils.clearAttempts(email);
      
      // Create session
      const session = SessionUtils.createSession(foundUser);
      
      const userInfo = {
        id: foundUser.id,
        email: foundUser.email,
        name: foundUser.name,
        phone: foundUser.phone,
        role: foundUser.role,
        session: session
      };
      
      // Log successful login
      AuditUtils.logSecurityEvent('LOGIN_SUCCESS', { 
        userId: foundUser.id, 
        email: foundUser.email,
        sessionId: session.sessionId
      });
      
      setUser(userInfo);
      return { success: true };
    } else {
      // Try code-based authentication for regular users
      return await loginWithCode(email, password);
    }
  };

  const loginWithCode = async (email, code) => {
    // Check if code exists and is valid
    const accessCode = userAccessCodes[code];
    
    if (!accessCode) {
      SessionUtils.recordFailedAttempt(email);
      AuditUtils.logSecurityEvent('LOGIN_FAILED', { 
        email: email,
        reason: 'Invalid access code'
      });
      return { success: false, error: 'Invalid access code' };
    }

    if (accessCode.isUsed) {
      return { success: false, error: 'Access code has already been used' };
    }

    if (new Date() > new Date(accessCode.expiresAt)) {
      return { success: false, error: 'Access code has expired' };
    }

    // Check if user already exists
    let existingUser = userDatabase[email];
    
    if (!existingUser) {
      // Create new user account
      const newUserId = Date.now().toString();
      const newUser = {
        id: newUserId,
        email: email,
        name: email.split('@')[0], // Use email prefix as default name
        phone: '',
        role: 'user',
        createdAt: new Date().toISOString(),
        createdBy: accessCode.createdBy,
        registeredWithCode: code
      };

      setUserDatabase(prev => ({
        ...prev,
        [email]: newUser
      }));

      existingUser = newUser;

      AuditUtils.logSecurityEvent('USER_REGISTERED_WITH_CODE', {
        userId: newUser.id,
        email: email,
        code: code
      });
    }

    // Mark code as used
    setUserAccessCodes(prev => ({
      ...prev,
      [code]: { ...prev[code], isUsed: true, usedBy: email, usedAt: new Date().toISOString() }
    }));

    // Clear failed attempts
    SessionUtils.clearAttempts(email);
    
    // Create session
    const session = SessionUtils.createSession(existingUser);
    
    const userInfo = {
      id: existingUser.id,
      email: existingUser.email,
      name: existingUser.name,
      phone: existingUser.phone,
      role: existingUser.role,
      session: session
    };
    
    // Log successful login
    AuditUtils.logSecurityEvent('LOGIN_SUCCESS', { 
      userId: existingUser.id, 
      email: existingUser.email,
      sessionId: session.sessionId,
      method: 'access_code'
    });
    
    setUser(userInfo);
    return { success: true };
  };

  const generateAccessCode = async (email) => {
    if (user?.role !== 'admin') {
      return { success: false, error: 'Only admins can generate access codes' };
    }

    // Generate a unique 8-character code
    const code = Math.random().toString(36).substring(2, 10).toUpperCase();
    
    const newAccessCode = {
      code: code,
      isUsed: false,
      createdBy: user.email,
      createdAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
      forEmail: email || 'any' // Can be restricted to specific email or 'any'
    };

    setUserAccessCodes(prev => ({
      ...prev,
      [code]: newAccessCode
    }));

    AuditUtils.logSecurityEvent('ACCESS_CODE_GENERATED', {
      code: code,
      generatedBy: user.email,
      forEmail: email || 'any'
    });

    return { success: true, code: code, expiresAt: newAccessCode.expiresAt };
  };

  const getAccessCodes = () => {
    if (user?.role !== 'admin') {
      return [];
    }
    return Object.values(userAccessCodes);
  };

  const revokeAccessCode = async (code) => {
    if (user?.role !== 'admin') {
      return { success: false, error: 'Only admins can revoke access codes' };
    }

    if (!userAccessCodes[code]) {
      return { success: false, error: 'Access code not found' };
    }

    setUserAccessCodes(prev => {
      const newCodes = { ...prev };
      delete newCodes[code];
      return newCodes;
    });

    AuditUtils.logSecurityEvent('ACCESS_CODE_REVOKED', {
      code: code,
      revokedBy: user.email
    });

    return { success: true, message: 'Access code revoked successfully' };
  };

  const logout = async () => {
    // For demo purposes, we'll just clear the user state
    // In a real app, you would remove from AsyncStorage here
    setUser(null);
  };

  const updateProfile = async (updatedInfo) => {
    const updatedUser = { ...user, ...updatedInfo };
    
    // Update in mock database
    setUserDatabase(prev => ({
      ...prev,
      [user.email]: { ...prev[user.email], ...updatedInfo }
    }));
    
    // For demo purposes, we'll just update the user state
    // In a real app, you would save to AsyncStorage here
    setUser(updatedUser);
    
    return { success: true };
  };

  const createUser = async (userData) => {
    if (user?.role !== 'admin') {
      return { success: false, error: 'Only admins can create users' };
    }

    // Validate all inputs
    const nameValidation = ValidationUtils.validateName(userData.name);
    if (!nameValidation.isValid) {
      return { success: false, error: nameValidation.error };
    }

    const emailValidation = ValidationUtils.validateEmail(userData.email);
    if (!emailValidation.isValid) {
      return { success: false, error: emailValidation.error };
    }

    const passwordValidation = ValidationUtils.validatePassword(userData.password);
    if (!passwordValidation.isValid) {
      return { success: false, error: passwordValidation.error };
    }

    const phoneValidation = ValidationUtils.validatePhone(userData.phone);
    if (!phoneValidation.isValid) {
      return { success: false, error: phoneValidation.error };
    }

    if (userDatabase[userData.email]) {
      return { success: false, error: 'User already exists' };
    }

    // Hash password (in demo, we'll just store plaintext)
    // In production: const hashedPassword = EncryptionUtils.hashPassword(userData.password);
    
    const newUser = {
      id: Date.now().toString(),
      name: ValidationUtils.sanitizeInput(userData.name),
      email: userData.email.toLowerCase(),
      password: userData.password, // In production, use hashedPassword
      phone: userData.phone,
      role: userData.role,
      createdAt: new Date().toISOString(),
      createdBy: user.id
    };

    setUserDatabase(prev => ({
      ...prev,
      [userData.email]: newUser
    }));

    // Log user creation
    AuditUtils.logSecurityEvent('USER_CREATED', {
      newUserId: newUser.id,
      newUserEmail: newUser.email,
      newUserRole: newUser.role,
      createdBy: user.id
    });

    return { success: true, message: 'User created successfully' };
  };

  const getAllUsers = () => {
    if (user?.role !== 'admin') {
      return [];
    }
    return Object.values(userDatabase);
  };

  const deleteUser = async (email) => {
    if (user?.role !== 'admin') {
      return { success: false, error: 'Only admins can delete users' };
    }

    if (email === user.email) {
      return { success: false, error: 'Cannot delete your own account' };
    }

    setUserDatabase(prev => {
      const newDb = { ...prev };
      delete newDb[email];
      return newDb;
    });

    return { success: true, message: 'User deleted successfully' };
  };

  const value = {
    user,
    loading,
    login,
    loginWithCode,
    logout,
    updateProfile,
    createUser,
    getAllUsers,
    deleteUser,
    generateAccessCode,
    getAccessCodes,
    revokeAccessCode,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};